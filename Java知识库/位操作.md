## 按位与 (AND)

**按位与**运算，用符号 `&` 表示，是位运算中最基础也最常用的一个。它直接作用于两个整数的二进制表示，逐位进行比较。

### 核心规则

按位与的规则很简单：**只有当两个对应的二进制位都为 `1` 时，结果位才为 `1`。否则，结果位为 `0`。**

我们可以用真值表来表示这个规则：

| 位 A | 位 B | A & B |
| :--- | :--- | :---- |
| 0    | 0    | 0     |
| 0    | 1    | 0     |
| 1    | 0    | 0     |
| 1    | 1    | 1     |

导出到 Google 表格

### 运算示例

让我们通过具体的例子来看看它是如何工作的：

**例 1：正数之间的按位与**

计算 **\$5 \\\\text{ & } 3\$**：

1. **转换为二进制：**

   * **5\_**(**10**)**=**0101\_**(**2**)**
   * **3\_**(**10**)**=**0011\_**(**2**)**
2. **逐位进行 AND 运算：**

   ```
     0101  (5)
   & 0011  (3)
   -------
     0001  (1)
   ```

   * 最低位：**\$1 \\\\text{ & } 1 = 1\$**
   * 第二位：**\$0 \\\\text{ & } 1 = 0\$**
   * 第三位：**\$1 \\\\text{ & } 0 = 0\$**
   * 最高位：**\$0 \\\\text{ & } 0 = 0\$**
3. **结果：**0001\_**(**2**)**=**1\_**(**10**)。所以，**\$5 \\\\text{ & } 3 = 1\$**。

**例 2：包含零的按位与**

计算 **\$6 \\\\text{ & } 0\$**:

1. **转换为二进制：**
   * **6\_**(**10**)**=**0110\_**(**2**)**
   * **0\_**(**10**)**=**0000\_**(**2**)**
2. **逐位进行 AND 运算：**
   ```
     0110  (6)
   & 0000  (0)
   -------
     0000  (0)
   ```
3. **结果：**0000\_**(**2**)**=**0\_**(**10**)。所以，**\$6 \\\\text{ & } 0 = 0\$**。

### 按位与的常见用途

按位与在实际编程中非常有用，尤其是在需要操作数据特定位的情况下：

1. #### **清零特定位**

   将任何位与 `0` 进行按位与运算，结果总是 `0`。 例如，如果你想将一个数 `N` 的某个特定位清零，可以创建一个掩码，该掩码在目标位是 `0`，其他位是 `1`。 比如，`X & 0` 结果永远是 `0`。


   * **示例：** 假设我们想清零二进制数 `0110` (十进制 6) 的第三位（从右往左数，从 0 开始）。

     * 需要一个掩码，第三位是 0，其他位是 1：`1011` (十进制 11)。 <!-- end list -->

     ```
       0110  (6)
     & 1011  (11)
     -------
       0010  (2)  -> 成功将第三位清零
     ```
2. #### **提取特定位（掩码）**

   这是按位与最常见的应用之一。通过与一个称为“**掩码（Mask）**”的数进行 `&` 运算，可以**保留**某些位的值，而将其他位清零。掩码在需要保留的位上是 `1`，在需要清零的位上是 `0`。


   * **示例：** 如果我们只想获取一个数 `N` 的最低位（即判断奇偶性）：
     * 掩码就是 `1` (二进制 `...0001`)。
     * `N & 1`：
       * 如果 `N` 的最低位是 `1`，那么 `1 & 1 = 1`，结果是 `1`。
       * 如果 `N` 的最低位是 `0`，那么 `0 & 1 = 0`，结果是 `0`。
3. #### **判断奇偶性**

   这是提取特定位的一个特例，但非常重要且常用。


   * **规则：**`N & 1`
     * 如果结果是 `1`，说明 `N` 的最低位是 `1`，`N` 是**奇数**。
     * 如果结果是 `0`，说明 `N` 的最低位是 `0`，`N` 是**偶数**。
   * **示例：**
     * 判断 7 (奇数) 的奇偶性：
       ```
         0111  (7)
       & 0001  (1)
       -------
         0001  (1)  -> 结果是 1，7 是奇数
       ```
     * 判断 8 (偶数) 的奇偶性：
       ```
         1000  (8)
       & 0001  (1)
       -------
         0000  (0)  -> 结果是 0，8 是偶数
       ```
4. #### **检查特定位的状态**

   你可以检查一个数 `N` 的第 `k` 位是否为 `1`。


   * 方法：将 `N` 与 `(1 << k)`（一个只有第 `k` 位是 `1` 的数）进行按位与运算。
   * 如果结果不为 `0`，说明第 `k` 位是 `1`。
   * 如果结果为 `0`，说明第 `k` 位是 `0`。
   * **示例：** 检查 **10\_**(**10**) (`1010_{(2)}`) 的第二位（从右往左数，0-indexed）：

     * `1 << 2` 得到 `0100_{(2)}` (十进制 4)。

     <!-- end list -->

     ```
       1010  (10)
     & 0100  (4)
     -------
       0000  (0)  -> 结果是 0，说明第 2 位是 0。
     ```

     * 实际上 **10\_**(**10**) 的第二位确实是 0。


















# 什么是异或（XOR）？

异或（**Exclusive OR**），通常写作 **XOR**，是计算机科学和数字逻辑中一个基本的逻辑运算符。它的核心思想是“两者不同则真，两者相同则假”。

## 异或的定义

* **符号：** 通常用 **o**pl**u**s、**t**e**x**t**XOR** 或 **\$\\\\text{^}\$** 表示。
* **真值表：**

| 输入 A | 输入 B | A XOR B |
| :----- | :----- | :------ |
| 假 (0) | 假 (0) | 假 (0)  |
| 假 (0) | 真 (1) | 真 (1)  |
| 真 (1) | 假 (0) | 真 (1)  |
| 真 (1) | 真 (1) | 假 (0)  |

从真值表可以看出，当两个输入（A 和 B）不同时，异或运算的结果为真（1）；当两个输入相同时，结果为假（0）。

## 异或的特性

异或运算有一些非常有趣的特性，使其在很多场景下非常有用：

**1. 交换律：A ^ B = B ^ A**
**2. 结合律： (A ^ B) ^ C = A ^ (B ^ C)**
**3. 自反性：A ^ A = 0 (任何数和自己异或都等于 0)**
**4. 恒等律：A ^ 0 = A (任何数和 0 异或都等于它本身)**
**5. 消去律（或自逆性）： 如果 A ^ B = C，那么 C ^ B = A。这意味着异或运算可以用来“撤销”之前的操作。**

## 异或的常见应用

异或运算在计算机领域有广泛的应用，例如：

* **数据加密：** 由于异或的自逆性，可以简单地使用相同的密钥进行加密和解密。例如，`加密数据 = 原始数据 XOR 密钥`，然后 `原始数据 = 加密数据 XOR 密钥`。
* **位操作：**

  * **交换两个变量的值（不使用临时变量）：** 这是一个经典的面试题。
    ```
    A = A ^ B;
    B = A ^ B; // 此时 B = (A ^ B) ^ B = A
    A = A ^ B; // 此时 A = (A ^ B) ^ A = B
    ```
  * **查找数组中出现奇数次的数字：** 如果一个数组中只有一个数字出现奇数次，其他数字都出现偶数次，那么将数组中所有数字进行异或运算，最终结果就是那个出现奇数次的数字。因为偶数次异或会相互抵消（**X**o**pl**u**s**X**=**0）。

```
// 异或法
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 5, 4, 2, 3, 1, 6);
        sort(numbers);
        int result = 0;
        int i = 1;
        for (Integer num : numbers) {
            System.out.println("第" + i + "个数: " + num);
            result ^= num;
            System.out.println("异或操作后的数: " + result);
            i++;
        }
```

* **校验和与错误检测：** 异或常用于生成简单的校验码，以检测数据传输或存储过程中是否发生错误。例如，奇偶校验位就是一种简单的异或应用。
* **RAID 系统：** 在 RAID 阵列中，异或用于计算奇偶校验信息，以实现数据的冗余和恢复。
